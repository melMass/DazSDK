<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="expires" content="0">
<title>DAZ Studio SDK: mycustomshape.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="docstyle.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>mycustomshape.cpp </h1>  </div>
</div>
<div class="contents">
<dl class="user"><dt><b>Source:</b></dt><dd><a href="../samples/saving/customelements">./sdk/samples/saving/customelements</a></dd></dl>
<div class="fragment"><pre class="fragment"><span class="comment">/**********************************************************************</span>
<span class="comment">    Copyright (C) 2011 DAZ 3D, Inc. All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">    This file is part of the DAZ Studio SDK.</span>
<span class="comment"></span>
<span class="comment">    This file may be used only in accordance with the DAZ Studio SDK </span>
<span class="comment">    license provided with the DAZ Studio SDK.</span>
<span class="comment"></span>
<span class="comment">    The contents of this file may not be disclosed to third parties, </span>
<span class="comment">    copied or duplicated in any form, in whole or in part, without the </span>
<span class="comment">    prior written permission of DAZ 3D, Inc, except as explicitly</span>
<span class="comment">    allowed in the DAZ Studio SDK license.</span>
<span class="comment"></span>
<span class="comment">    See http://www.daz3d.com to contact DAZ 3D, Inc or for more </span>
<span class="comment">    information about the DAZ Studio SDK.</span>
<span class="comment">**********************************************************************/</span>

<span class="preprocessor">#include &quot;mycustomshape.h&quot;</span>
<span class="preprocessor">#include &lt;<a class="code" href="dzvertexmesh_8h.html">dzvertexmesh.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="idzjsonio_8h.html">idzjsonio.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="dzobject_8h.html">dzobject.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="dzdrawstyle_8h.html">dzdrawstyle.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="dzfloatcolor_8h.html">dzfloatcolor.h</a>&gt;</span>

<span class="keyword">struct </span>MyNurbShape::Data
{
    MyNurbGeometry*      m_geom;
    <span class="keyword">mutable</span> <a class="code" href="class_dz_facet_mesh.html" title="A general polygon mesh.">DzFacetMesh</a>* m_mesh;
};

MyNurbShape::MyNurbShape(MyNurbGeometry* geom)
    : m_data(new Data)
{
    <span class="keyword">static</span> <span class="keywordtype">int</span> handle = 0;
    setObjectName(QString(<span class="stringliteral">&quot;MyNurbShape%1&quot;</span>).arg(++handle));
    <span class="keywordflow">if</span> (!geom)
        geom = <span class="keyword">new</span> MyNurbGeometry();
    m_data-&gt;m_geom = geom;
}

MyNurbShape::~MyNurbShape()
{
    <span class="keyword">delete</span> m_data;
}

<a class="code" href="class_dz_geometry.html" title="The base class for all mesh or geometry type objects.">DzGeometry</a>* <a class="code" href="class_dz_shape.html#ab69268768e9b74bbc49a3e90006fbb9f">MyNurbShape::getGeometry</a>()<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> m_data-&gt;m_geom;
}

<a class="code" href="class_dz_vertex_mesh.html" title="Base class for meshes that have a list of vertices.">DzVertexMesh</a>* MyNurbShape::getModifiableGeom( <span class="keywordtype">bool</span> isRender, <a class="code" href="class_dz_vertex_mesh.html" title="Base class for meshes that have a list of vertices.">DzVertexMesh</a> *currentCache )<span class="keyword"> const</span>
<span class="keyword"></span>{
    m_data-&gt;m_mesh = <span class="keyword">new</span> <a class="code" href="class_dz_facet_mesh.html" title="A general polygon mesh.">DzFacetMesh</a>();
    m_data-&gt;m_mesh-&gt;setVertexArray(m_data-&gt;m_geom-&gt;getNumVertices());
    m_data-&gt;m_mesh-&gt;removeAllFacets();

    <a class="code" href="dzgeneraldefs_8h.html#a5c8fff8ac8fa1548b78738a31c2c1528">DzPnt3</a>* a = m_data-&gt;m_geom-&gt;getVerticesPtr();
    <a class="code" href="dzgeneraldefs_8h.html#a5c8fff8ac8fa1548b78738a31c2c1528">DzPnt3</a>* b = m_data-&gt;m_mesh-&gt;getVerticesPtr();

    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0, n = m_data-&gt;m_geom-&gt;getNumVertices(); i &lt; n; i++)
    {
        b[i][0] = a[i][0];
        b[i][1] = a[i][1];
        b[i][2] = a[i][2];
    }

    <span class="keywordflow">return</span> m_data-&gt;m_mesh;
}

<span class="keywordtype">void</span> MyNurbShape::draw( <span class="keyword">const</span> <a class="code" href="class_dz_draw_style.html" title="Encapsulates the drawing parameters for a 3D view.">DzDrawStyle</a> &amp;style, <span class="keyword">const</span> <a class="code" href="class_dz_geometry.html" title="The base class for all mesh or geometry type objects.">DzGeometry</a> *wsGeom, <span class="keyword">const</span> <a class="code" href="class_dz_node.html" title="Base class for objects that can participate in a transform hierarchy.">DzNode</a> *node )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">if</span>( style.<a class="code" href="class_dz_draw_style.html#adbd63439722f54b03477b157eeb70338">shadeStyle</a>() == DzDrawStyle::PICKING ) {
        <span class="keywordflow">return</span>;
    }

    <span class="keywordflow">switch</span>( style.<a class="code" href="class_dz_draw_style.html#adbd63439722f54b03477b157eeb70338">shadeStyle</a>() ) {
    <span class="keywordflow">case</span> <a class="code" href="class_dz_draw_style.html#aa2edf31cf0e4d7c4983303043d2586b8a80363dbfc3ddafa707e8566d801ae59b">DzDrawStyle::SmoothShaded</a>:
    <span class="keywordflow">case</span> <a class="code" href="class_dz_draw_style.html#aa2edf31cf0e4d7c4983303043d2586b8a2767ac501b1f7b6394d44fe10d9e28ab">DzDrawStyle::Textured</a>:
        {
            <span class="keywordflow">if</span> (!m_data-&gt;m_mesh-&gt;getNumFacets())
                m_data-&gt;m_geom-&gt;tesselate(m_data-&gt;m_mesh);

            <a class="code" href="class_dz_float_color.html" title="A 4-component floating point color value.">DzFloatColor</a> diffuse(1, 1, 1);
            <a class="code" href="class_dz_float_color.html" title="A 4-component floating point color value.">DzFloatColor</a> specular(1, 1, 1);
            <a class="code" href="class_dz_float_color.html" title="A 4-component floating point color value.">DzFloatColor</a> ambient(0, 0, 0);

            glColor4fv( diffuse.getValue() );
            glMaterialfv( GL_FRONT_AND_BACK, GL_AMBIENT, ambient.getValue() );
            glMaterialfv( GL_FRONT_AND_BACK, GL_SPECULAR, specular.getValue() );

            glBegin(GL_QUADS);
            <a class="code" href="dzgeneraldefs_8h.html#a5c8fff8ac8fa1548b78738a31c2c1528">DzPnt3</a>* vertices = m_data-&gt;m_mesh-&gt;getVerticesPtr();
            <a class="code" href="dzgeneraldefs_8h.html#a5c8fff8ac8fa1548b78738a31c2c1528">DzPnt3</a>* normals = m_data-&gt;m_mesh-&gt;getNormalsPtr();
            <a class="code" href="class_dz_facet.html" title="Represents a polygonal face.">DzFacet</a>* facets = m_data-&gt;m_mesh-&gt;getFacetsPtr();
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0, n = m_data-&gt;m_mesh-&gt;getNumFacets(); i &lt; n; i++)
            {
                glNormal3fv(normals[facets[i].m_normIdx[0]]);
                glVertex3fv(vertices[facets[i].m_vertIdx[0]]);

                glNormal3fv(normals[facets[i].m_normIdx[1]]);
                glVertex3fv(vertices[facets[i].m_vertIdx[1]]);

                glNormal3fv(normals[facets[i].m_normIdx[2]]);
                glVertex3fv(vertices[facets[i].m_vertIdx[2]]);

                glNormal3fv(normals[facets[i].m_normIdx[3]]);
                glVertex3fv(vertices[facets[i].m_vertIdx[3]]);
            }
            glEnd();
        }
        <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>:
        {
            glColor4f(1, 1, 0, 1);

            glBegin(GL_POINTS);
            <a class="code" href="dzgeneraldefs_8h.html#a5c8fff8ac8fa1548b78738a31c2c1528">DzPnt3</a>* vertices = wsGeom-&gt;<a class="code" href="class_dz_geometry.html#a7c69ae4d8148889a2ba9bbad028f4a7e">getVerticesPtr</a>();
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0, n = wsGeom-&gt;<a class="code" href="class_dz_geometry.html#a1135b4ec8edf5b7f65181651355f3c40">getNumVertices</a>(); i &lt; n; i++)
            {
                glVertex3fv(vertices[i]);
            }
            glEnd();
        }
        <span class="keywordflow">break</span>;
    }

}

<span class="keywordtype">void</span> MyNurbShape::render( <span class="keyword">const</span> <a class="code" href="class_dz_render_settings.html" title="Pairs an instance of a DzRenderer with an instance of a DzRenderOptions object.">DzRenderSettings</a> &amp;settings, <span class="keyword">const</span> <a class="code" href="class_dz_geometry.html" title="The base class for all mesh or geometry type objects.">DzGeometry</a> *wsGeom, <span class="keyword">const</span> <a class="code" href="class_dz_node.html" title="Base class for objects that can participate in a transform hierarchy.">DzNode</a> *node )<span class="keyword"> const</span>
<span class="keyword"></span>{
}


<span class="keywordtype">void</span> MyNurbShape::invalidateWorkingMesh()
{
}



<span class="keyword">struct </span>MyNurbGeometry::Data
{
    <span class="keywordtype">int</span> dimensionU;
    <span class="keywordtype">int</span> dimensionV;
    QVector&lt;float&gt; m_weights;
    QVector&lt;float&gt; m_knotVectorU;
    QVector&lt;float&gt; m_knotVectorV;
};


<span class="keyword">static</span> <span class="keywordtype">double</span> s_vertices[] = {
    -1.92061738543705,-1.22071424910243e-016,1.9935776583948,1,-0.640205795145684,-1.22071424910243e-016,1.9935776583948,1,0.640205795145684,-1.22071424910243e-016,1.9935776583948,1,1.92061738543705,-1.22071424910243e-016,1.9935776583948,1,-1.92061738543705,-4.0690474970081e-017,0.664525886131598,1,-0.640205795145684,-4.0690474970081e-017,0.664525886131598,1,0.640205795145684,-4.0690474970081e-017,0.664525886131598,1,1.92061738543705,-4.0690474970081e-017,0.664525886131598,1,-1.92061738543705,4.0690474970081e-017,-0.664525886131598,1,-0.640205795145684,4.0690474970081e-017,-0.664525886131598,1,0.640205795145684,4.0690474970081e-017,-0.664525886131598,1,1.92061738543705,4.0690474970081e-017,-0.664525886131598,1,-1.92061738543705,1.22071424910243e-016,-1.9935776583948,1,-0.640205795145684,1.22071424910243e-016,-1.9935776583948,1,0.640205795145684,1.22071424910243e-016,-1.9935776583948,1,1.92061738543705,1.22071424910243e-016,-1.9935776583948,1
};

MyNurbGeometry::MyNurbGeometry()
    : m_data(new Data)
{
    <span class="keyword">static</span> <span class="keywordtype">int</span> handle = 0;
    setObjectName(QString(<span class="stringliteral">&quot;MyNurbGeometry%1&quot;</span>).arg(++handle));

    m_data-&gt;dimensionU = 0;
    m_data-&gt;dimensionV = 0;

}

MyNurbGeometry::~MyNurbGeometry()
{
    <span class="keyword">delete</span> m_data;
}

<span class="keywordtype">void</span> MyNurbGeometry::setupExample()
{
    m_data-&gt;dimensionU = 4;
    m_data-&gt;dimensionV = 4;

    m_data-&gt;m_knotVectorU.push_back(0);
    m_data-&gt;m_knotVectorU.push_back(0);
    m_data-&gt;m_knotVectorU.push_back(0);
    m_data-&gt;m_knotVectorU.push_back(0);
    m_data-&gt;m_knotVectorU.push_back(1);
    m_data-&gt;m_knotVectorU.push_back(1);
    m_data-&gt;m_knotVectorU.push_back(1);
    m_data-&gt;m_knotVectorU.push_back(1);

    m_data-&gt;m_knotVectorV.push_back(0);
    m_data-&gt;m_knotVectorV.push_back(0);
    m_data-&gt;m_knotVectorV.push_back(0);
    m_data-&gt;m_knotVectorV.push_back(0);
    m_data-&gt;m_knotVectorV.push_back(1);
    m_data-&gt;m_knotVectorV.push_back(1);
    m_data-&gt;m_knotVectorV.push_back(1);
    m_data-&gt;m_knotVectorV.push_back(1);
    
    beginEdit(<span class="keyword">false</span>);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_data-&gt;dimensionU; i++)
    {
        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j = 0 ; j &lt; m_data-&gt;dimensionV; j++)
        {
            <span class="keywordtype">int</span> index = (i*m_data-&gt;dimensionV+j)*4;
            addVertex(
                s_vertices[index+0],
                s_vertices[index+1],
                s_vertices[index+2]
            ); 
            m_data-&gt;m_weights.push_back(
                s_vertices[index+3]
            );
        }
    }
    finishEdit();
}

<span class="keyword">const</span> QObject* MyNurbGeometry::toQObject()<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> <span class="keyword">this</span>;
}

QObject* MyNurbGeometry::toQObject()
{
    <span class="keywordflow">return</span> <span class="keyword">this</span>;
}

IDzSceneAsset::AssetType MyNurbGeometry::getAssetType()<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> GeometryAsset;
}




<a class="code" href="class_dz_vertex_mesh.html" title="Base class for meshes that have a list of vertices.">DzVertexMesh</a>* MyNurbGeometry::makeCopy( <span class="keywordtype">bool</span> shareVerts, <span class="keywordtype">bool</span> shareFacets )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> 0;
}


<span class="keywordtype">bool</span> <a class="code" href="class_dz_vertex_mesh.html#ae8c61b1ae18585dd4fd7ad8c6f887192">MyNurbGeometry::copyFrom</a>( <a class="code" href="class_dz_vertex_mesh.html" title="Base class for meshes that have a list of vertices.">DzVertexMesh</a> *mesh, <span class="keywordtype">bool</span> shareVerts <span class="comment">/*= false*/</span>, <span class="keywordtype">bool</span> shareFacets <span class="comment">/*= false */</span> )
{
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}


<a class="code" href="class_dz_box3.html" title="A 3D box.">DzBox3</a> MyNurbGeometry::getGroupBoundingBox( <span class="keyword">const</span> QString &amp;groupName )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> getBoundingBox();
}

<a class="code" href="class_dz_oriented_box3.html" title="An oriented 3D box.">DzOrientedBox3</a>  MyNurbGeometry::getGroupOrientedBox( <span class="keyword">const</span> QString &amp;groupName, <span class="keyword">const</span> <a class="code" href="class_dz_vec3.html" title="A 3D vector class.">DzVec3</a> &amp;pos, <span class="keyword">const</span> <a class="code" href="class_dz_quat.html" title="A quaternion rotation class.">DzQuat</a> &amp;rot, <span class="keyword">const</span> <a class="code" href="class_dz_vec3.html" title="A 3D vector class.">DzVec3</a> &amp;scale )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> getOrientedBox(pos, rot, scale);
}

<a class="code" href="class_dz_box3.html" title="A 3D box.">DzBox3</a> MyNurbGeometry::getGroupBoundingBox( <span class="keyword">const</span> QString &amp;groupName, <span class="keyword">const</span> <a class="code" href="class_dz_matrix3.html" title="A 4 x 3 transformation matrix.">DzMatrix3</a> &amp;transform )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> getBoundingBox();
}

<a class="code" href="class_dz_oriented_box3.html" title="An oriented 3D box.">DzOrientedBox3</a> MyNurbGeometry::getGroupOrientedBox( <span class="keyword">const</span> QString &amp;groupName, <span class="keyword">const</span> <a class="code" href="class_dz_matrix3.html" title="A 4 x 3 transformation matrix.">DzMatrix3</a> &amp;transform, <span class="keyword">const</span> <a class="code" href="class_dz_vec3.html" title="A 3D vector class.">DzVec3</a> &amp;pos, <span class="keyword">const</span> <a class="code" href="class_dz_quat.html" title="A quaternion rotation class.">DzQuat</a> &amp;rot, <span class="keyword">const</span> <a class="code" href="class_dz_vec3.html" title="A 3D vector class.">DzVec3</a> &amp;scale )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> getOrientedBox(pos, rot, scale);
}

<span class="keywordtype">bool</span> MyNurbGeometry::hasMultipleLOD()<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}

<span class="keywordtype">int</span> MyNurbGeometry::getNumLODs()<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> 0;
}

QString MyNurbGeometry::getLODName( <span class="keywordtype">int</span> which )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
}

<a class="code" href="class_dz_map.html" title="Base class for all property value maps. Meshes can have any number of maps of various types...">DzMap</a>* MyNurbGeometry::getUVs()<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span> MyNurbGeometry::getNumUVSets()<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> 0;
}

<a class="code" href="class_dz_u_v_set.html" title="Represents vertex map containing the data for a UV set.">DzUVSet</a>* MyNurbGeometry::getUVSet( <span class="keywordtype">int</span> which )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">void</span> MyNurbGeometry::tesselate(<a class="code" href="class_dz_facet_mesh.html" title="A general polygon mesh.">DzFacetMesh</a>* mesh)
{
    mesh-&gt;<a class="code" href="class_dz_facet_mesh.html#a11b07b8a80f30e827f4d1e75a34da080">beginEdit</a>(<span class="keyword">false</span>);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_data-&gt;dimensionU-1; i++)
    {
        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j = 0 ; j &lt; m_data-&gt;dimensionV-1; j++)
        {
            <span class="keywordtype">int</span> vertIdx[4];
            <span class="keywordtype">int</span> uvwIdx[4];
            vertIdx[0] = ((i+0)*m_data-&gt;dimensionV+j+0);
            vertIdx[1] = ((i+0)*m_data-&gt;dimensionV+j+1);
            vertIdx[2] = ((i+1)*m_data-&gt;dimensionV+j+1);
            vertIdx[3] = ((i+1)*m_data-&gt;dimensionV+j+0);
            uvwIdx[0] = 0;
            uvwIdx[1] = 0;
            uvwIdx[2] = 0;
            uvwIdx[3] = 0;
            mesh-&gt;<a class="code" href="class_dz_facet_mesh.html#afd7fad2296854b18a5636ada57ddf1f4">addFacet</a>(vertIdx, uvwIdx);
        }
    }
    mesh-&gt;<a class="code" href="class_dz_facet_mesh.html#a4a92feaf5c126bc97ebe4f400c5c1b91">finishEdit</a>();
}

MyNurbGeometryIO::MyNurbGeometryIO()
{
}

MyNurbGeometryIO::~MyNurbGeometryIO()
{
}

<a class="code" href="class_dz_geometry.html" title="The base class for all mesh or geometry type objects.">DzGeometry</a>* MyNurbGeometryIO::createGeometry()<span class="keyword">const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> <span class="keyword">new</span> MyNurbGeometry();
}

<a class="code" href="class_dz_shape.html" title="A container class for a geometry and related materials, etc.">DzShape</a>* MyNurbGeometryIO::createShape(<a class="code" href="class_dz_geometry.html" title="The base class for all mesh or geometry type objects.">DzGeometry</a>* geometry)<span class="keyword">const</span>
<span class="keyword"></span>{
    MyNurbShape* shape = <span class="keyword">new</span> MyNurbShape(qobject_cast&lt;MyNurbGeometry*&gt;(geometry));
    <span class="keywordflow">return</span> shape;
}

<a class="code" href="dzerrorcodes_8h.html#ad93d4cc3a92646c8afd11810e32f089a">DzError</a> MyNurbGeometryIO::writeExtraDefinition( QObject* <span class="keywordtype">object</span>, IDzJsonIO* io, <span class="keyword">const</span> <a class="code" href="class_dz_file_i_o_settings.html" title="Base class for all file I/O options. File I/O classes should use this to pass the options supported b...">DzFileIOSettings</a>* opts )<span class="keyword">const</span>
<span class="keyword"></span>{
    MyNurbGeometry* geom = qobject_cast&lt;MyNurbGeometry*&gt;(object);

    io-&gt;addMember(<span class="stringliteral">&quot;dimension_u&quot;</span>, geom-&gt;m_data-&gt;dimensionU);
    io-&gt;addMember(<span class="stringliteral">&quot;dimension_v&quot;</span>, geom-&gt;m_data-&gt;dimensionV);
    io-&gt;startMemberArray(<span class="stringliteral">&quot;points&quot;</span>);
    <a class="code" href="dzgeneraldefs_8h.html#a5c8fff8ac8fa1548b78738a31c2c1528">DzPnt3</a>* vertices = geom-&gt;getVerticesPtr();

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; geom-&gt;m_data-&gt;m_weights.size(); i++)
    {
        io-&gt;startArray(<span class="keyword">false</span>);
        io-&gt;addItem(vertices[i][0]);
        io-&gt;addItem(vertices[i][1]);
        io-&gt;addItem(vertices[i][2]);
        io-&gt;addItem(geom-&gt;m_data-&gt;m_weights[i]);
        io-&gt;finishArray();
    }
    io-&gt;finishArray();

    io-&gt;startMemberArray(<span class="stringliteral">&quot;knot_vectors&quot;</span>);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; geom-&gt;m_data-&gt;m_knotVectorU.size(); i++)
    {
        io-&gt;startArray(<span class="keyword">false</span>);
        io-&gt;addItem(geom-&gt;m_data-&gt;m_knotVectorU[i]);
        io-&gt;addItem(geom-&gt;m_data-&gt;m_knotVectorV[i]);
        io-&gt;finishArray();
    }
    io-&gt;finishArray();

    <span class="keywordflow">return</span> DZ_NO_ERROR;
}

<a class="code" href="dzerrorcodes_8h.html#ad93d4cc3a92646c8afd11810e32f089a">DzError</a> MyNurbGeometryIO::writeExtraInstance( QObject* <span class="keywordtype">object</span>, IDzJsonIO* io, <span class="keyword">const</span> <a class="code" href="class_dz_file_i_o_settings.html" title="Base class for all file I/O options. File I/O classes should use this to pass the options supported b...">DzFileIOSettings</a>* opts )<span class="keyword">const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> DZ_NO_ERROR;
}

DzAssetJsonObject* MyNurbGeometryIO::startDefinitionRead( DzAssetJsonItem* parentItem )
{
    m_context = <span class="keyword">new</span> Context(parentItem-&gt;getFile());
    <span class="keywordflow">return</span> <span class="keyword">new</span> ReadMyNurbGeometry(m_context);
}

DzAssetJsonObject* MyNurbGeometryIO::startInstanceRead( DzAssetJsonItem* parentItem )
{
    m_context = <span class="keyword">new</span> Context(parentItem-&gt;getFile());
    <span class="keywordflow">return</span> <span class="keyword">new</span> ReadMyNurbGeometry(m_context);
}

<a class="code" href="dzerrorcodes_8h.html#ad93d4cc3a92646c8afd11810e32f089a">DzError</a> MyNurbGeometryIO::applyDefinitionToObject( QObject* <span class="keywordtype">object</span>, <span class="keyword">const</span> <a class="code" href="class_dz_file_i_o_settings.html" title="Base class for all file I/O options. File I/O classes should use this to pass the options supported b...">DzFileIOSettings</a>* opts )<span class="keyword">const</span>
<span class="keyword"></span>{
    MyNurbGeometry* geom = qobject_cast&lt;MyNurbGeometry*&gt;(object);

    geom-&gt;m_data-&gt;dimensionU = m_context-&gt;m_dimensionU;
    geom-&gt;m_data-&gt;dimensionV = m_context-&gt;m_dimensionV;

    <span class="keywordflow">if</span> (m_context-&gt;m_points.size() != m_context-&gt;m_weights.size()
        || geom-&gt;m_data-&gt;dimensionU*geom-&gt;m_data-&gt;dimensionV != m_context-&gt;m_points.size())
        <span class="keywordflow">return</span> DZ_INDEX_OUT_OF_RANGE_ERROR;
    <span class="keywordflow">if</span> (m_context-&gt;m_knotVectorUs.size() != m_context-&gt;m_knotVectorVs.size())
        <span class="keywordflow">return</span> DZ_INDEX_OUT_OF_RANGE_ERROR;


    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_context-&gt;m_points.size(); i++)
    {
        geom-&gt;addVertex(
            m_context-&gt;m_points[i].m_x,
            m_context-&gt;m_points[i].m_y,
            m_context-&gt;m_points[i].m_z
            );
        geom-&gt;m_data-&gt;m_weights.push_back(m_context-&gt;m_weights[i]);
    }

    geom-&gt;m_data-&gt;m_knotVectorU = m_context-&gt;m_knotVectorUs;
    geom-&gt;m_data-&gt;m_knotVectorV = m_context-&gt;m_knotVectorUs;

    <span class="keywordflow">return</span> DZ_NO_ERROR;
}

<a class="code" href="dzerrorcodes_8h.html#ad93d4cc3a92646c8afd11810e32f089a">DzError</a> MyNurbGeometryIO::applyInstanceToObject( QObject* <span class="keywordtype">object</span>, <span class="keyword">const</span> <a class="code" href="class_dz_file_i_o_settings.html" title="Base class for all file I/O options. File I/O classes should use this to pass the options supported b...">DzFileIOSettings</a>* opts )<span class="keyword">const</span>
<span class="keyword"></span>{
    MyNurbShape* shape = qobject_cast&lt;MyNurbShape*&gt;(object);
    MyNurbGeometry* geom = qobject_cast&lt;MyNurbGeometry*&gt;(shape-&gt;getGeometry());
    <span class="keywordflow">return</span> DZ_NO_ERROR;
}



<span class="keywordtype">bool</span> ReadMyNurbGeometry::addMember( <span class="keyword">const</span> QString &amp;name, <span class="keywordtype">double</span> val )
{
    <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;dimension_u&quot;</span>) {
        m_context-&gt;m_dimensionU = val;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;dimension_v&quot;</span>) {
        m_context-&gt;m_dimensionV = val;
    }
    <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> DzAssetJsonObject::addMember(name, val);
    }
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

DzAssetJsonItem* ReadMyNurbGeometry::startMemberArray( <span class="keyword">const</span> QString &amp;name )
{
    <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;points&quot;</span>) {
        <span class="keywordflow">return</span> <span class="keyword">new</span> ReadMyNurbPoints(m_context);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;knot_vectors&quot;</span>) {
        <span class="keywordflow">return</span> <span class="keyword">new</span> ReadMyNurbKnots(m_context);
    }
    <span class="keywordflow">else</span> {
        <span class="keywordflow">return</span> DzAssetJsonObject::startMemberArray(name);
    }
}

DzAssetJsonItem* ReadMyNurbPoints::startArray()
{
    m_context-&gt;m_points.push_back(<a class="code" href="class_dz_vec3.html" title="A 3D vector class.">DzVec3</a>(0, 0, 0));
    m_context-&gt;m_weights.push_back(0);
    <span class="keywordflow">return</span> <span class="keyword">new</span> ReadMyNurbPoint(m_context);
}

<span class="keywordtype">bool</span> ReadMyNurbPoint::addItem(<span class="keywordtype">double</span> val )
{
    <span class="keywordtype">int</span> index = m_context-&gt;m_points.size() - 1;
    <span class="keywordflow">switch</span>(m_i)
    {
    <span class="keywordflow">case</span> 0:
    <span class="keywordflow">case</span> 1:
    <span class="keywordflow">case</span> 2:
        m_context-&gt;m_points[index][m_i++] = val; 
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    <span class="keywordflow">case</span> 3:
        m_context-&gt;m_weights[index] = val; 
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    <span class="keywordflow">default</span>:
        <span class="keywordflow">return</span> DzAssetJsonArray::addItem(val);
    }
}


DzAssetJsonItem* ReadMyNurbKnots::startArray()
{
    m_context-&gt;m_knotVectorUs.push_back(0);
    m_context-&gt;m_knotVectorVs.push_back(0);
    <span class="keywordflow">return</span> <span class="keyword">new</span> ReadMyNurbKnot(m_context);
}

<span class="keywordtype">bool</span> ReadMyNurbKnot::addItem(<span class="keywordtype">double</span> val )
{
    <span class="keywordtype">int</span> index = m_context-&gt;m_knotVectorUs.size() - 1;
    <span class="keywordflow">switch</span>(m_i)
    {
    <span class="keywordflow">case</span> 0: 
        m_context-&gt;m_knotVectorUs[index] = val; 
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    <span class="keywordflow">case</span> 1: 
        m_context-&gt;m_knotVectorVs[index] = val; 
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    <span class="keywordflow">default</span>:
        <span class="keywordflow">return</span> DzAssetJsonArray::addItem(val);
    }
}
</pre></div> </div>
<hr size="1">
<address style="align: right;">
<small> Generated on Tue Aug 14 2012 17:20:06</small>
</address>
<h3 align="center">Copyright &copy; 2002 - 2012 DAZ 3D, Inc.</h3>
</body>
</html>
