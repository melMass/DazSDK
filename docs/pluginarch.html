<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="expires" content="0">
<title>DAZ Studio SDK: DAZ Studio Plug-in Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="docstyle.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>DAZ Studio Plug-in Architecture </h1>  </div>
</div>
<div class="contents">
<p>DAZ Studio was designed as an application that could be readily extended by plug-ins to add new features and functionality. Plug-in modules are distributed as dynamically loaded libraries - dll files on Windows, and dylib files on Mac OSX. A plug-in that has been compiled for DAZ Studio can simply be dropped into the 'plugins/' folder in the DAZ Studio install directory, and that plug-in will then be loaded automatically when DAZ Studio is started.</p>
<p>The DAZ Studio SDK is written in C++, and is completely Object Oriented. Developing plug-ins for DAZ Studio requires a good knowledge of C++ and Object Oriented programming practices. If you are unfamiliar with C++, or want to get your feet wet with the DAZ Studio SDK before jumping all the way in, you should try out DAZ Script - it provides essentially the same interface as the full SDK, but without needing to compile and link a plug-in. DAZ Scripts can even be written, editted and executed right inside of DAZ Studio, there's no need to have or learn to use any other tools. See the DAZ Script documentation for more information.</p>
<p>Plug-ins extend DAZ Studio by adding new class types to the application. These classes will always be subclasses of <a class="el" href="class_dz_base.html" title="Base class for nearly all DAZ SDK objects.">DzBase</a>, or one of the DzBase-derived classes available through the SDK. <a class="el" href="class_dz_base.html" title="Base class for nearly all DAZ SDK objects.">DzBase</a> and QObject provide the RTTI (run time type information) that allow the core application to create and use class types that it is unfamiliar with. Each plug-in provides an instance of the <a class="el" href="class_dz_plugin.html" title="Class that defines a DAZ Studio plug-in.">DzPlugin</a> class which handles startup and shutdown functions for the plug-in, and most importantly maintains the list of class types that are added to the application by the plug-in.</p>
<p>Getting started is almost always easiest by using an existing example as a starting point. This ensures the flags and options are set correctly and quickly confirms the build environment works as expected. While the following information explains details that should already be setup if starting from an example, new GUIDs will be needed.</p>
<p>Each plug-in must export two functions:</p>
<ul>
<li><b>unsigned int getSDKVersion():</b> returns the version of the SDK that the plug-in was compiled against so that the core can verify that the plug-in has the correct linkages.</li>
<li><b><a class="el" href="class_dz_plugin.html" title="Class that defines a DAZ Studio plug-in.">DzPlugin</a> *getPluginDefinition():</b> returns a pointer to a static instance of the <a class="el" href="class_dz_plugin.html" title="Class that defines a DAZ Studio plug-in.">DzPlugin</a> class, which the core uses to load the plug-in.</li>
</ul>
<p>The easiest way to define these functions is to use the macro <a class="el" href="pluginmacros.html#dz_plugin_definition">DZ_PLUGIN_DEFINITION()</a>. This macro automatically defines both functions and creates a default static instance of <a class="el" href="class_dz_plugin.html" title="Class that defines a DAZ Studio plug-in.">DzPlugin</a> which is sufficient for most plug-ins. If your plug-in needs something that the default <a class="el" href="class_dz_plugin.html" title="Class that defines a DAZ Studio plug-in.">DzPlugin</a> class does not provide (e.g. custom startup and shutdown routines), then you can subclass <a class="el" href="class_dz_plugin.html" title="Class that defines a DAZ Studio plug-in.">DzPlugin</a> and use the <a class="el" href="pluginmacros.html#dz_custom_plugin_definition">DZ_CUSTOM_PLUGIN_DEFINITION()</a> macro instead. Additional information about these and other macros that assist with defining a plug-in can be found in <a class="el" href="pluginmacros.html">DAZ Studio Plug-in Macros</a>.</p>
<p>After defining the plug-in, all you need to do is add to it the classes that your plug-in exports. This can be easily done by using the <a class="el" href="pluginmacros.html#dz_plugin_class_guid">DZ_PLUGIN_CLASS_GUID()</a> macro.</p>
<p>To demonstrate using these macros to create a new plug-in, the following example is given:</p>
<p>This code might be found in a header for a new exporter class to be included in a new plug-in: </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// the class definition of a new exporter class</span>
    <span class="keyword">class </span>MyExporter : <a class="code" href="class_dz_exporter.html" title="Base class for all scene file exporters.">DzExporter</a> {
        MyExporter();
    };
</pre></div><p>This code might be found in a header for a new importer class to be included in the same plug-in: </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// the class definition of a new importer class</span>
    <span class="keyword">class </span>MyImporter : <a class="code" href="class_dz_importer.html" title="Base class for all file importers.">DzImporter</a> {
        MyImporter();
    };
</pre></div><p>The following code would then be found in one of the source files for the new plug-in </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Creates a static instance of the DzPlugin class, and defines the getPluginDefinition() function</span>
    DZ_PLUGIN_DEFINITION( <span class="stringliteral">&quot;My Plug-in&quot;</span> );

    <span class="comment">// Use the DZ_PLUGIN_CLASS_GUID macro to add classes to the plug-in definition</span>
    DZ_PLUGIN_CLASS_GUID( MyExporter, 3422F77F-E85A-490d-B854-7D6E88E9DF07 )
    DZ_PLUGIN_CLASS_GUID( MyImporter, 488C7575-88CD-468e-9C29-9125DE74218A )
</pre></div><p>The above example shows all the necessary code to create a new exporter class, and a new importer class; create class factories for the new types; and add them to a plug-in definition. These macros must be used in a source file, where they will only be compiled once. <a class="el" href="pluginmacros.html#dz_plugin_definition">DZ_PLUGIN_DEFINITION()</a> should appear only once in a single source file for a given plug-in, and must preceed the use of <a class="el" href="pluginmacros.html#dz_plugin_class_guid">DZ_PLUGIN_CLASS_GUID()</a>.</p>
<p>Each class exported from a plug-in ( via <a class="el" href="pluginmacros.html#dz_plugin_class_guid">DZ_PLUGIN_CLASS_GUID()</a> ) must have a unique class identifier. In DAZ Studio, we now use GUIDs (Globally Unique Identifiers) which can be easily generated by the plug-in developer on their own machine, see <a class="el" href="classids.html">DAZ Studio Class IDs</a> for more information about class identifiers.</p>
<p>Additionally, plug-ins can also be configured to provide an evaluation period, and also optionally require that a user register them with a serial number. For more information about implementing this functionality see <a class="el" href="pluginreg.html">DAZ Studio Plug-in Activation and Serialization</a>.</p>
<p>If you are compiling on Windows, you will need to make sure that you export the two functions created by the <a class="el" href="pluginmacros.html#dz_plugin_definition">DZ_PLUGIN_DEFINITION()</a> macro. This is usually accomplished by adding the following lines to a definition (*.def) file for the project:</p>
<div class="fragment"><pre class="fragment">    EXPORTS
        getSDKVersion           @1
        getPluginDefinition     @2
</pre></div><p>If you are compiling on Mac OS X, you should make sure that <b>only</b> the two functions created by the <a class="el" href="pluginmacros.html#dz_plugin_definition">DZ_PLUGIN_DEFINITION()</a> macro are exported by your plug-in. By default the GCC compiler exports all symbols defined in a dynamic library. You can change this behaviour by using the -exported_symbols_list linker option. In Xcode the "Exported Symbols File" build setting can be used to set this option. You set the build setting to the path of a file that contains the symbols to export. The contents of the file should look like this:</p>
<div class="fragment"><pre class="fragment">    _getSDKVersion
    _getPluginDefinition
</pre></div><p>Such a file, called "exportedPluginSymbols.txt", is already included in the SDK, in the "include" folder. The "Exported Symbols File" setting should be set with the path to this file.</p>
<p>That's it! Now you should be on your way to writing and compiling your first DAZ Studio plug-in. </p>
</div>
<hr size="1">
<address style="align: right;">
<small> Generated on Tue Aug 14 2012 17:20:06</small>
</address>
<h3 align="center">Copyright &copy; 2002 - 2012 DAZ 3D, Inc.</h3>
</body>
</html>
