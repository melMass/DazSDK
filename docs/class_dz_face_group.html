<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="expires" content="0">
<title>DAZ Studio SDK: DzFaceGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="docstyle.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Functions</a>  </div>
  <div class="headertitle">
<h1>DzFaceGroup Class Reference<br/>
<small>
[<a class="el" href="group___objects.html">Object and Geometry Classes</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="DzFaceGroup" --><!-- doxytag: inherits="DzIndexList,DzRefCountedItem" -->
<p>A collection of faces.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dzfacegroup_8h_source.html">dzfacegroup.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DzFaceGroup:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_dz_face_group.png" usemap="#DzFaceGroup_map" alt=""/>
  <map id="DzFaceGroup_map" name="DzFaceGroup_map">
<area href="class_dz_index_list.html" alt="DzIndexList" shape="rect" coords="0,56,115,80"/>
<area href="class_dz_ref_counted_item.html" alt="DzRefCountedItem" shape="rect" coords="125,56,240,80"/>
<area href="class_dz_base.html" alt="DzBase" shape="rect" coords="0,0,115,24"/>
</map>
</div>

<p><a href="class_dz_face_group-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dz_face_group.html#aa315220bf0bd0ebb84fa3f0afcb19200">DzFaceGroup</a> (const QString &amp;name=QString::null)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dz_face_group.html#a273eca37b424ce684282f91e41c52480">DzFaceGroup</a> (const <a class="el" href="class_dz_face_group.html">DzFaceGroup</a> &amp;grp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_dz_face_group.html#a78fa9c34593a12a64def1a0d56e17283">~DzFaceGroup</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A collection of faces. </p>
<p>Represents a list of faces from a geometry that are collected into a group. The group is stored as a list of integers which are indices into the face list of the geometry which this group references.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The geometry that this group references</dd></dl>
<p><a class="el" href="class_dz_facet_mesh.html" title="A general polygon mesh.">DzFacetMesh</a> *DzFaceGroupgetOwner() const { return m_data-&gt;m_owner; }</p>
<p>/**  </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of unique vertices that are used by faces in this face group. This is a fairly expensive call.</dd></dl>
<p>int DzFaceGroup::getNumVerts() const { <a class="el" href="class_dz_t_sorted_array.html">DzTSortedArray&lt;int&gt;</a> verts;</p>
<p>getVertices( verts );</p>
<p>return verts.count(); }</p>
<p>/**  Get a list of verts referenced by this face group. Collects all the unique verts that are referenced by faces in this group. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>verts</em>&nbsp;</td><td>Array to add the vertex indices to.</td></tr>
  </table>
  </dd>
</dl>
<p>void DzFaceGroup::getVertices( DzTSortedArray&lt;int&gt; &amp;verts ) const { int i, num, idx;</p>
<p>if( m_data-&gt;m_owner == NULL ) return;</p>
<p>const int *fIdx = <a class="el" href="class_dz_index_list.html#a2287a4a60b2824d73fa1cfa8566927f3">getIndicesPtr()</a>; <a class="el" href="class_dz_facet.html" title="Represents a polygonal face.">DzFacet</a> *facets = m_data-&gt;m_owner-&gt;getFacetsPtr();</p>
<p>num = <a class="el" href="class_dz_index_list.html#a811bcedf425de9ad999bd4f4fa1102fe">count()</a>; for( i = 0; i &lt; num; ++i ) { idx = fIdx[i]; verts.add( facets[idx].m_vertIdx[0] ); verts.add( facets[idx].m_vertIdx[1] ); verts.add( facets[idx].m_vertIdx[2] );</p>
<p>if( facets[idx].isQuad() ) verts.add( facets[idx].m_vertIdx[3] ); } }</p>
<p>/**  Get a list of boundary verts referenced by this face group. Collects all the unique verts that lie on the border (i.e. seam) of the group. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>verts</em>&nbsp;</td><td>Array to add the vertex indices to.</td></tr>
  </table>
  </dd>
</dl>
<p>void DzFaceGroup::getBoundaryVertices( DzTSortedArray&lt;int&gt; &amp;verts ) const { if( m_data-&gt;m_owner == NULL ) return; // Have to have a valid owner to find boundary faces.</p>
<p>int i, nEdges; DzTSortedArray&lt;DzIndexedVertexPair&gt; edges( 512 );</p>
<p>getEdges( edges );</p>
<p>Now go back and find out which edges were only referenced once and add the face index for that edge to the list of boundary face indices. nEdges = edges.count(); for( i = 0; i &lt; nEdges; ++i ) { if( edges[i].m_useCount &lt; 2 ) { verts.add( edges[i].m_vert1 ); verts.add( edges[i].m_vert2 ); } } }</p>
<p>/**  Fills the passed array with all vertex-paired edges that exists in this face group. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edges</em>&nbsp;</td><td>This array will be populated with the edge list for this face group.</td></tr>
  </table>
  </dd>
</dl>
<p>void DzFaceGroup::getEdges( DzTSortedArray&lt;DzIndexedVertexPair&gt; &amp;edges ) const { if( m_data-&gt;m_owner == NULL ) return; // Have to have a valid owner to find edges.</p>
<p>int i, num; DzTSortedArray&lt;DzIndexedVertexPair&gt; sortedEdges; DzTBlockArray&lt;DzIndexedVertexPair&gt; tempEdges( 128 ); const <a class="el" href="class_dz_indexed_vertex_pair.html" title="A geometry &#39;edge&#39; represented as a pair of vertex indexes.">DzIndexedVertexPair</a> *edgeList; <a class="el" href="class_dz_indexed_vertex_pair.html" title="A geometry &#39;edge&#39; represented as a pair of vertex indexes.">DzIndexedVertexPair</a> edge, *finalEdges;</p>
<p>get a sorted list of edges with duplicates. getAllEdges( sortedEdges );</p>
<p>cull out the duplicates num = sortedEdges.count(); if( num &lt; 1 ) return;</p>
<p>edgeList = sortedEdges.getValues(); edge = (*edgeList); edgeList++; for( i = 1; i &lt; num; i++, edgeList++ ){ if( (*edgeList) == edge ) edge.m_useCount++; else{ tempEdges.append( edge ); edge = (*edgeList); } } tempEdges.append( edge );</p>
<p>num = tempEdges.count(); edges.setCount( num ); finalEdges = edges.getValuesUnlocked(); tempEdges.copyToArray( finalEdges ); }</p>
<p>/**  Collects all the edges used by faces in this group. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edges</em>&nbsp;</td><td>This array will be populated with the edge list for this face group including duplicates.</td></tr>
  </table>
  </dd>
</dl>
<p>void DzFaceGroup::getAllEdges( DzTSortedArray&lt;DzIndexedVertexPair&gt; &amp;edges ) const { assert( m_data-&gt;m_owner ); if( !m_data-&gt;m_owner ) return;</p>
<p>int i, j; int fIdx; int vCur, vPrev; <a class="el" href="class_dz_indexed_vertex_pair.html" title="A geometry &#39;edge&#39; represented as a pair of vertex indexes.">DzIndexedVertexPair</a> pair; DzTBlockArray&lt;DzIndexedVertexPair&gt; tempEdges( 128 ); <a class="el" href="class_dz_facet.html" title="Represents a polygonal face.">DzFacet</a> *facets = m_data-&gt;m_owner-&gt;getFacetsPtr(); const int *indices = <a class="el" href="class_dz_index_list.html#a2287a4a60b2824d73fa1cfa8566927f3">getIndicesPtr()</a>;</p>
<p>build an unsorted list of all edges int numIndices = <a class="el" href="class_dz_index_list.html#a811bcedf425de9ad999bd4f4fa1102fe">count()</a>; for( i = 0; i &lt; numIndices; ++i ) { fIdx = indices[i];</p>
<p>int numEdges = 0; if( facets[fIdx].isQuad() ) numEdges = 4; else numEdges = 3;</p>
<p>vPrev = facets[fIdx].m_vertIdx[numEdges-1];</p>
<p>for( j = 0; j &lt; numEdges; ++j ) { vCur = facets[fIdx].m_vertIdx[j];</p>
<p>if( vCur &gt;= 0 ){ pair.setVerts( vPrev, vCur ); pair.m_firstFaceIdx = fIdx;</p>
<p>tempEdges.append( pair ); vPrev = vCur; } } }</p>
<p>sort the list (no duplicates are culled out) edges = tempEdges; }</p>
<p>/**  </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer to the array of primitive index buffers for the geometry data of this group. This pointer should not be deleted or stored.</dd></dl>
<p>const DzTArray&lt;DzPrimIndexBuffer&gt;* DzFaceGroup::getPrimIndexBuffers() const { return &amp;m_data-&gt;m_primIndexBuffers; }</p>
<p>/**  Clears the list of primitive index buffers for the geometry data of this group.</p>
<p>void DzFaceGroup::clearPrimIndexBuffers() { m_data-&gt;m_primIndexBuffers.clear(); }</p>
<p>/**  Sets the list of primitive index buffers for the geometry data of this group. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>primIndexBuffer</em>&nbsp;</td><td>The array of primitive index buffers to set.</td></tr>
  </table>
  </dd>
</dl>
<p>void DzFaceGroup::setPrimIndexBuffers(DzTArray&lt;DzPrimIndexBuffer&gt;&amp; primIndexBuffer) { m_data-&gt;m_primIndexBuffers = primIndexBuffer; }</p>
<p>/**  Sets the flag of using VBO rendering. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>use</em>&nbsp;</td><td>If use if "true" VBOs will be used for rendering the geometry data of this group, otherwise the geometry will be rendered in the immediate mode.</td></tr>
  </table>
  </dd>
</dl>
<p>void DzFaceGroup::setUseVBORendering( bool use ) { m_data-&gt;m_useVBORendering = use; }</p>
<p>/**  </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The flag of using VBO rendering.</dd></dl>
<p>bool DzFaceGroup::getUseVBORendering() const { return m_data-&gt;m_useVBORendering; }</p>
<p>///////////////////////////////////////////////////////////////////// DzMaterialFaceGroup ///////////////////////////////////////////////////////////////////// /**  </p>
<p>Represents a list of faces from a geometry that are collected into a group. The group is stored as a list of integers which are indices into the face list of the geometry which this group references. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa315220bf0bd0ebb84fa3f0afcb19200"></a><!-- doxytag: member="DzFaceGroup::DzFaceGroup" ref="aa315220bf0bd0ebb84fa3f0afcb19200" args="(const QString &amp;name=QString::null)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DzFaceGroup::DzFaceGroup </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>QString::null</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor. Creates a new facegroup. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>owner</em>&nbsp;</td><td>The mesh that this face group is for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name for this face group </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addAllFaces</em>&nbsp;</td><td>If true, all faces in the mesh will be added to the new group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a273eca37b424ce684282f91e41c52480"></a><!-- doxytag: member="DzFaceGroup::DzFaceGroup" ref="a273eca37b424ce684282f91e41c52480" args="(const DzFaceGroup &amp;grp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DzFaceGroup::DzFaceGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_dz_face_group.html">DzFaceGroup</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>grp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>grp</em>&nbsp;</td><td>The group to make a copy of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78fa9c34593a12a64def1a0d56e17283"></a><!-- doxytag: member="DzFaceGroup::~DzFaceGroup" ref="a78fa9c34593a12a64def1a0d56e17283" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DzFaceGroup::~DzFaceGroup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. </p>

</div>
</div>
</div>
<hr size="1">
<address style="align: right;">
<small> Generated on Tue Aug 14 2012 17:20:17</small>
</address>
<h3 align="center">Copyright &copy; 2002 - 2012 DAZ 3D, Inc.</h3>
</body>
</html>
